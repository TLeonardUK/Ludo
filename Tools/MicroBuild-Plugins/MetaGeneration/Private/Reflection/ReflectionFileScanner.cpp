/*
Ludo Game Engine
Copyright (C) 2016 TwinDrills

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "PCH.h"

#include "BuildTool/Private/Reflection/ReflectionFileScanner.h"

//#define LD_OPT_DUMP_REFLECTION_SCAN_LOG 1

// Current state:
//	Ignores varidic arguments.
//	Ignores varidic templates.
//  Ignore global scope variables & functions.
//	Does not have default datatype types.
//	No associated attributes (super class, is-abstract, etc)
//  No access to private members
//  Does not support #pragma once properly on files included via forced-include.

namespace Ludo {

ReflectionFileScanner::ReflectionFileScanner(
	const Path& SourceFile, 
	const Path& OutputFile, 
	const Path& DependentsOutputPath, 
	const String& FileId,
	const Array<String>& ClangArguments,
	bool bTreatAsPch
)
	: m_SourcePath(SourceFile)
	, m_OutputPath(OutputFile)
	, m_DependentsOutputPath(DependentsOutputPath)
	, m_ClangArguments(ClangArguments)
	, m_FileId(FileId)
	, m_TreatAsPch(bTreatAsPch)
{
}

ReflectionFileScanner::~ReflectionFileScanner()
{
	for (Class* Cls : m_Classes)
	{
		LD_ARENA_DELETE(LibCMemoryArena, Cls);
	}
	m_Classes.Empty();
}

enum CXChildVisitResult ReflectionFileScanner::VisitGlobalNodeThunk(CXCursor Cursor, CXCursor Parent, CXClientData ClientData)
{
	ReflectionFileScanner* Command = reinterpret_cast<ReflectionFileScanner*>(ClientData);
	return Command->VisitGlobalNode(Cursor, Parent);
}

enum CXChildVisitResult ReflectionFileScanner::VisitGlobalNode(CXCursor Cursor, CXCursor Parent)
{
	UNUSED_PARAMETER(Parent);

	CXCursorKind Kind = clang_getCursorKind(Cursor);

	CXFile LocationFile;
	CXSourceLocation Location = clang_getCursorLocation(Cursor);
	clang_getSpellingLocation(Location, &LocationFile, nullptr, nullptr, nullptr);
	CXString LocationFileString = clang_getFileName(LocationFile);
	
	// clang_Location_isFromMainFile is a god dam lie, if node is generated by token expansion from a macro
	// in another head, then it lies out its ass.
//	bool bInMainFile = (clang_Location_isFromMainFile(Location) != 0);
	CXChildVisitResult result = CXChildVisit_Continue;

	switch (Kind)
	{
		case CXCursor_ClassTemplate:
		case CXCursor_StructDecl:
		case CXCursor_ClassDecl:
		{
			// Ignore forward-references.
			if (clang_isCursorDefinition(Cursor))
			{
				if (Kind == CXCursor_ClassTemplate)
				{
					if (m_PendingAttributes.Length() > 0)
					{
						WriteError(Cursor, LogWarning, String::Format("Template and varidic methods, functions and classes are ignored by the reflection system, unneccesary meta data defined for '%s'.", clang_getCString(clang_getCursorSpelling(Cursor))));
					}
				}
				else
				{
					CXString CxName = clang_getCursorSpelling(Cursor);
					m_KnownClassNames.Add(clang_getCString(CxName));
					clang_disposeString(CxName);

					bool bInMainFile = LocationFile == nullptr ? false : (String(clang_getCString(LocationFileString)) == m_SourcePath.ToString());

					if (bInMainFile)
					{
						VisitClass(Cursor, (Kind == CXCursor_StructDecl));
					}
				}
			}
			break;

		}

		case CXCursor_EnumDecl:
		{
			// Ignore forward-references.
			if (clang_isCursorDefinition(Cursor))
			{
				bool bInMainFile = LocationFile == nullptr ? false : (String(clang_getCString(LocationFileString)) == m_SourcePath.ToString());

				if (bInMainFile)
				{
					VisitEnum(Cursor);
				}
			}

			break;
		}

		case CXCursor_EnumConstantDecl:
		{
			VisitEnumKey(Cursor);
			break;
		}

		case CXCursor_Namespace:
		{
			result = CXChildVisit_Recurse;
			break;
		}
	}

	return result;
}

enum CXChildVisitResult ReflectionFileScanner::VisitChildNodeThunk(CXCursor Cursor, CXCursor Parent, CXClientData ClientData)
{
	UNUSED_PARAMETER(Parent);

	ReflectionFileScanner* Command = reinterpret_cast<ReflectionFileScanner*>(ClientData);
	return Command->VisitChildNode(Cursor, Parent);
}

enum CXChildVisitResult ReflectionFileScanner::VisitChildNode(CXCursor Cursor, CXCursor Parent)
{
	UNUSED_PARAMETER(Parent);

	CXCursorKind Kind = clang_getCursorKind(Cursor);
	CXChildVisitResult result = CXChildVisit_Continue;

#if LD_OPT_DUMP_REFLECTION_SCAN_LOG
	CXString CxName = clang_getCursorSpelling(Cursor);
	LogF(LogTool, LogInfo, "[%i] = %s", Kind, clang_getCString(CxName));
	clang_disposeString(CxName);
#endif

	switch (Kind)
	{
		case CXCursor_ClassTemplate:
		case CXCursor_StructDecl:
		case CXCursor_ClassDecl:
		{
			// Ignore forward-references.
			if (clang_isCursorDefinition(Cursor))
			{
				if (Kind == CXCursor_ClassTemplate)
				{
					if (m_PendingAttributes.Length() > 0)
					{
						WriteError(Cursor, LogWarning, String::Format("Template and varidic methods, functions and classes are ignored by the reflection system, unneccesary meta data defined for '%s'.", clang_getCString(clang_getCursorSpelling(Cursor))));
						m_PendingAttributes.Empty();
					}
				}
				else
				{
					if (*m_AccessSpecifierStack.Last() == CX_CXXPublic)
					{
						CXString CxName = clang_getCursorSpelling(Cursor);
						m_KnownClassNames.Add(clang_getCString(CxName));
						clang_disposeString(CxName);

						// Nested structs and classes :(
						VisitClass(Cursor, (Kind == CXCursor_StructDecl));
					}
					else
					{
						if (m_PendingAttributes.Length() > 0)
						{
							WriteError(Cursor, LogWarning, String::Format("Private and protected members are not exposed by the reflection system, unneccesary meta data defined for '%s'.", clang_getCString(clang_getCursorSpelling(Cursor))));
						}
					}
				}
			}

			break;
		}

		case CXCursor_EnumDecl:
		{
			// Ignore forward-references.
			if (clang_isCursorDefinition(Cursor))
			{
				if (*m_AccessSpecifierStack.Last() == CX_CXXPublic)
				{
					VisitEnum(Cursor);
				}
			}

			break;
		}

		case CXCursor_CXXBaseSpecifier:
		{
			Class* Cls = GetSemanticClass();
			CXType BaseType = clang_getCursorType(Cursor);
			CXString BaseTypeString = clang_getTypeFullyQualifiedSpelling(BaseType);

			Cls->m_BaseClassesRaw.Add(StringId::Create(clang_getCString(BaseTypeString)));

			clang_disposeString(BaseTypeString);

			break;
		}

		case CXCursor_CXXAccessSpecifier:
		{
			*m_AccessSpecifierStack.Last() = clang_getCXXAccessSpecifier(Cursor);
			break;
		}

		case CXCursor_VarDecl:
		case CXCursor_FieldDecl:
		{
			// We only care if we are inside a class.
			if (m_SemanticStack.Length() > 0)
			{
				if (*m_AccessSpecifierStack.Last() == CX_CXXPublic)
				{
					VisitField(Cursor);
				}
				else
				{
					if (m_PendingAttributes.Length() > 0)
					{
						WriteError(Cursor, LogWarning, String::Format("Private and protected members are not exposed by the reflection system, unneccesary meta data defined for '%s'.", clang_getCString(clang_getCursorSpelling(Cursor))));
					}
				}
			}
			break;
		}

		case CXCursor_FunctionTemplate:
		case CXCursor_Constructor:
		case CXCursor_Destructor:
		case CXCursor_CXXMethod:
		case CXCursor_FunctionDecl:
		{
			// We only care if we are inside a class.
			if (m_SemanticStack.Length() > 0)
			{
				if (*m_AccessSpecifierStack.Last() == CX_CXXPublic)
				{
					if (clang_Cursor_isVariadic(Cursor) || Kind == CXCursor_FunctionTemplate)
					{
						if (m_PendingAttributes.Length() > 0)
						{
							WriteError(Cursor, LogWarning, String::Format("Template and varidic methods, functions and classes are ignored by the reflection system, unneccesary meta data defined for '%s'.", clang_getCString(clang_getCursorSpelling(Cursor))));
							m_PendingAttributes.Empty();
						}
					}
					else
					{
						if (Kind == CXCursor_Destructor)
						{
							if (m_PendingAttributes.Length() > 0)
							{
								WriteError(Cursor, LogWarning, String::Format("Destructors are not exposed by reflection system, unneccesary meta data defined for '%s'.", clang_getCString(clang_getCursorSpelling(Cursor))));
								m_PendingAttributes.Empty();
							}
						}
						else if (Kind == CXCursor_Constructor)
						{
							if (*m_AccessSpecifierStack.Last() != CX_CXXPublic)
							{
								WriteError(Cursor, LogWarning, String::Format("Non-public constructors are not exposed by reflection system, unneccesary meta data defined for '%s'.", clang_getCString(clang_getCursorSpelling(Cursor))));
								m_PendingAttributes.Empty();
							}
							else
							{
								VisitMethod(Cursor, true);
							}
						}
						else
						{
							VisitMethod(Cursor, false);
						}
					}
				}
				else
				{
					if (m_PendingAttributes.Length() > 0)
					{
						WriteError(Cursor, LogWarning, String::Format("Private and protected members are not exposed by the reflection system, unneccesary meta data defined for '%s'.", clang_getCString(clang_getCursorSpelling(Cursor))));
					}
				}
			}
			break;
		}
	}

	return result;
}

enum CXChildVisitResult ReflectionFileScanner::VisitAttributesNodeThunk(CXCursor Cursor, CXCursor Parent, CXClientData ClientData)
{
	UNUSED_PARAMETER(Parent);

	ReflectionFileScanner* Command = reinterpret_cast<ReflectionFileScanner*>(ClientData);
	return Command->VisitAttributesNode(Cursor, Parent);
}

enum CXChildVisitResult ReflectionFileScanner::VisitAttributesNode(CXCursor Cursor, CXCursor Parent)
{
	UNUSED_PARAMETER(Parent);

	CXCursorKind Kind = clang_getCursorKind(Cursor);
	CXChildVisitResult result = CXChildVisit_Continue;

	switch (Kind)
	{
	case CXCursor_AnnotateAttr:
	{
		VisitAttribute(Cursor);
		break;
	}
	}

	return result;
}

String ReflectionFileScanner::GetCursorFullName(CXCursor Cursor)
{
	String FullName = "";

	while (clang_Cursor_isNull(Cursor) == false &&
		   clang_getCursorKind(Cursor) != CXCursor_TranslationUnit)
	{
		CXString DisplayName = clang_getCursorDisplayName(Cursor);

		String FinalName = clang_getCString(DisplayName);

		if (clang_getCursorKind(Cursor) == CXCursor_CXXMethod)
		{
			if (clang_CXXMethod_isConst(Cursor))
			{
				FinalName += " const";
			}
		}

		if (FullName.IsEmpty())
		{
			FullName = FinalName;
		}
		else
		{
			FullName = String::Format("%s::%s", FinalName.Data(), FullName.Data());
		}

		Cursor = clang_getCursorSemanticParent(Cursor);
	}

	return FullName;
}

Class* ReflectionFileScanner::GetSemanticClass()
{
	return *m_ClassStack.Last();
}

StringId ReflectionFileScanner::RemoveRef(const StringId& Id)
{
	String Result = Id.ToString().Trim(" ");

	if (Result[Result.CharLength() - 1] == "&")
	{
		Result = Result.SubString(Result.BeginCharIterator(), Result.CharLength() - 1);
	}

	return StringId::Create(Result);
}

StringId ReflectionFileScanner::GenerateMetaClassName(const StringId& Id)
{
	return StringId::Create(String::Format("T%08x_%s", Id.ToString().ToHash(), Id.ToString().Filter("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_", "_").Data()));
}

void ReflectionFileScanner::FillTypeLocation(Type* NewType, CXCursor Cursor)
{
	CXSourceLocation Location = clang_getCursorLocation(Cursor);

	CXFile ClangFile;
	unsigned int Line;
	clang_getFileLocation(Location, &ClangFile, &Line, nullptr, nullptr);

	CXString ClangFileString = clang_getFileName(ClangFile);
	NewType->m_FileName = StringId::Create(clang_getCString(ClangFileString));
	NewType->m_Line = (int)Line;
	clang_disposeString(ClangFileString);
}

TypeAccessQualifier ReflectionFileScanner::GetCurrentAccessQualifier()
{
	CX_CXXAccessSpecifier Specifier = m_AccessSpecifierStack.Length() > 0 ? *m_AccessSpecifierStack.Last() : CX_CXXAccessSpecifier::CX_CXXPublic;

	if (Specifier == CX_CXXAccessSpecifier::CX_CXXPrivate)
	{
		return TypeAccessQualifier::Private;
	}
	else if (Specifier == CX_CXXAccessSpecifier::CX_CXXProtected)
	{
		return TypeAccessQualifier::Protected;
	}
	else if (Specifier == CX_CXXAccessSpecifier::CX_CXXPublic)
	{
		return TypeAccessQualifier::Public;
	}

	return TypeAccessQualifier::Public;
}

void ReflectionFileScanner::VisitEnumKey(CXCursor Cursor)
{
	Enum* Base = dynamic_cast<Enum*>(*m_SemanticStack.Last());
	if (Base == nullptr)
	{
		WriteError(Cursor, LogWarning, "Enum key not within enum declaration, parsing error?.");
		return;
	}

	CXString Name = clang_getCursorSpelling(Cursor);

	EnumKey Key;
	Key.m_Name = StringId::Create(clang_getCString(Name));
	Key.m_Enum = Base;
	Key.m_Value = clang_getEnumConstantDeclValue(Cursor);

	Base->m_Keys.Add(Key);

	clang_disposeString(Name);
}

void ReflectionFileScanner::VisitEnum(CXCursor Cursor)
{
	// Only care about things with meta attached to them.
	if (m_PendingAttributes.Length() == 0)
	{
		return;
	}

	CXString Name = clang_getCursorSpelling(Cursor);
	CXString USR = clang_getCursorUSR(Cursor);

	// New enum!
	Enum* NewEnum = LD_ARENA_NEW(LibCMemoryArena, Enum);
	NewEnum->m_Name = StringId::Create(clang_getCString(Name));
	NewEnum->m_FullName = StringId::Create(GetCursorFullName(Cursor));
	NewEnum->m_UUID = StringId::Create(clang_getCString(USR));
	NewEnum->m_MetaClassName = GenerateMetaClassName(NewEnum->m_FullName);
	NewEnum->m_RawAttributes = m_PendingAttributes;
	NewEnum->m_AccessQualifier = GetCurrentAccessQualifier();
	m_Enums.Push(NewEnum);
	FillTypeLocation(NewEnum, Cursor);

	m_PendingAttributes.Empty();

	// Cleanup
	clang_disposeString(Name);
	clang_disposeString(USR);

	// Visit all children.
	m_SemanticStack.Push(NewEnum);
	clang_visitChildren(Cursor, VisitChildNodeThunk, this);
	m_SemanticStack.Pop();
}

void ReflectionFileScanner::VisitField(CXCursor Cursor)
{
	// Only care about things with meta attached to them.
	if (m_PendingAttributes.Length() == 0)
	{
		return;
	}

	CXString Name = clang_getCursorSpelling(Cursor);
	CXString USR = clang_getCursorUSR(Cursor);

	CX_StorageClass Storage = clang_Cursor_getStorageClass(Cursor);

	// New method!
	Field* NewField = LD_ARENA_NEW(LibCMemoryArena, Field);
	NewField->m_Name = StringId::Create(clang_getCString(Name));
	NewField->m_FullName = StringId::Create(GetCursorFullName(Cursor));
	NewField->m_UUID = StringId::Create(clang_getCString(USR));
	NewField->m_MetaClassName = GenerateMetaClassName(NewField->m_FullName);
	NewField->m_RawAttributes = m_PendingAttributes;
	NewField->m_DataTypeRaw = GetCursorTypeString(clang_getCursorType(Cursor)); 
	NewField->m_DataTypeRawRefRemoved = RemoveRef(NewField->m_DataTypeRaw);
	NewField->m_ClassNameRaw = (*m_SemanticStack.Last())->GetFullName();
	NewField->m_bStatic = (Storage == CX_SC_Static);
	NewField->m_bConst = !!clang_isConstQualifiedType(clang_getCursorType(Cursor));
	NewField->m_AccessQualifier = GetCurrentAccessQualifier();
	FillTypeLocation(NewField, Cursor);

	m_PendingAttributes.Empty();

	m_Fields.Add(NewField);
	
#if LD_OPT_DUMP_REFLECTION_SCAN_LOG
	LogF(LogTool, LogInfo, "\tField: Name=%s, FullName=%s, UUID=%s, DataType=%s",
		NewField->m_Name.ToString().Data(),
		NewField->m_FullName.ToString().Data(),
		NewField->m_UUID.ToString().Data(),
		NewField->m_DataTypeRaw.ToString().Data()
	);
#endif

	// Add to class.
	Class* Class = GetSemanticClass();
	Class->m_Fields.Push(NewField);

	// Cleanup
	clang_disposeString(Name);
	clang_disposeString(USR);

	// Visit all children.
	m_SemanticStack.Push(NewField);

	clang_visitChildren(Cursor, VisitChildNodeThunk, this);

	m_SemanticStack.Pop();
}

StringId ReflectionFileScanner::GetCursorTypeString(CXType Type)
{
	return StringId::Create(clang_getCString(clang_getTypeFullyQualifiedSpelling(Type)));
}

void ReflectionFileScanner::VisitMethod(CXCursor Cursor, bool bConstructor)
{
	// Only care about things with meta attached to them.
	if (m_PendingAttributes.Length() == 0)
	{
		return;
	}

	CXString Name = clang_getCursorSpelling(Cursor);
	CXString USR = clang_getCursorUSR(Cursor);

	// We don't care about operator overloads.
	if (String(clang_getCString(Name)).StartsWith("operator"))
	{
		return;
	}

	// New method!
	Method* NewMethod = LD_ARENA_NEW(LibCMemoryArena, Method);
	NewMethod->m_Name = StringId::Create(clang_getCString(Name));
	NewMethod->m_FullName = StringId::Create(GetCursorFullName(Cursor));
	NewMethod->m_UUID = StringId::Create(clang_getCString(USR));
	NewMethod->m_MetaClassName = GenerateMetaClassName(NewMethod->m_FullName);
	NewMethod->m_RawAttributes = m_PendingAttributes;
	NewMethod->m_ReturnTypeRaw = GetCursorTypeString(clang_getResultType(clang_getCursorType(Cursor)));
	NewMethod->m_ReturnTypeRawRefRemoved = RemoveRef(NewMethod->m_ReturnTypeRaw);
	NewMethod->m_ClassNameRaw = (*m_SemanticStack.Last())->GetFullName();
	NewMethod->m_bConstructor = bConstructor;
	NewMethod->m_bStatic = !!clang_CXXMethod_isStatic(Cursor);
	NewMethod->m_bConst = !!clang_CXXMethod_isConst(Cursor);
	NewMethod->m_bVirtual = !!clang_CXXMethod_isVirtual(Cursor);
	NewMethod->m_bPureVirtual = !!clang_CXXMethod_isPureVirtual(Cursor);
	NewMethod->m_AccessQualifier = GetCurrentAccessQualifier();

	FillTypeLocation(NewMethod, Cursor);

	m_PendingAttributes.Empty();

	m_Methods.Add(NewMethod);

#if LD_OPT_DUMP_REFLECTION_SCAN_LOG
	LogF(LogTool, LogInfo, "\tMethod: Name=%s, FullName=%s, UUID=%s, ReturnType=%s",
		NewMethod->m_Name.ToString().Data(),
		NewMethod->m_FullName.ToString().Data(),
		NewMethod->m_UUID.ToString().Data(),
		NewMethod->m_ReturnTypeRaw.ToString().Data()
	);
#endif

	int ArgumentCount = clang_Cursor_getNumArguments(Cursor);
	NewMethod->m_Parameters.Resize(ArgumentCount);
	for (int i = 0; i < ArgumentCount; i++)
	{
		CXCursor ArgCursor = clang_Cursor_getArgument(Cursor, i);
		NewMethod->m_Parameters[i].DataTypeRaw = GetCursorTypeString(clang_getCursorType(ArgCursor));
		NewMethod->m_Parameters[i].DataTypeRawRefRemoved = RemoveRef(NewMethod->m_Parameters[i].DataTypeRaw);
		NewMethod->m_Parameters[i].Name = StringId::Create(clang_getCString(clang_getCursorSpelling(ArgCursor)));

		String V1 = GetCursorFullName(clang_getTypeDeclaration(clang_getCursorType(ArgCursor)));

//		if (NewMethod->m_Name.ToString().Contains("("))
//		{
//			LogF(LogTool, LogInfo, "Parameter=%s .");
//		}

		//if (NewMethod->m_Parameters[i].DataTypeRaw.ToString().Contains("ExceptionRecord"))
		//{
		//	LogF(LogTool, LogInfo, "At exception record.");
		//}

#if LD_OPT_DUMP_REFLECTION_SCAN_LOG
		LogF(LogTool, LogInfo, "\t\tParam: Name=%s Type=%s",
			NewMethod->m_Parameters[i].Name.ToString().Data(),
			NewMethod->m_Parameters[i].DataTypeRaw.ToString().Data()
		);
#endif
	}

	// Add to class.
	Class* Class = GetSemanticClass();
	Class->m_Methods.Push(NewMethod);

	if (NewMethod->m_bPureVirtual)
	{
		Class->m_bAbstract = true;
	}

	// Cleanup
	clang_disposeString(Name);
	clang_disposeString(USR);

	// Visit all children.
	m_SemanticStack.Push(NewMethod);

	clang_visitChildren(Cursor, VisitChildNodeThunk, this);

	m_SemanticStack.Pop();
}

void ReflectionFileScanner::VisitClass(CXCursor Cursor, bool bIsStruct)
{
	// Only care about things with meta attached to them.
	if (m_PendingAttributes.Length() == 0)
	{
		return;
	}

	CXString Name = clang_getCursorSpelling(Cursor);
	CXString USR = clang_getCursorUSR(Cursor);

	// Is this an attribute struct defined by Meta(), if so we don't want to add an actual class for it
	// but just parse out the attributes.
	String NameString = clang_getCString(Name);
	if (NameString.SubString(NameString.BeginCharIterator(), 14) == "_MetaAttribute")
	{
		clang_visitChildren(Cursor, VisitAttributesNodeThunk, this);
	}
	else
	{
		// We only care about classes derived from the Object base class.

		// New class!
		Class* NewClass = LD_ARENA_NEW(LibCMemoryArena, Class);
		NewClass->m_Name			= StringId::Create(NameString);
		NewClass->m_FullName		= StringId::Create(GetCursorFullName(Cursor));
		NewClass->m_UUID			= StringId::Create(clang_getCString(USR));
		NewClass->m_MetaClassName	= GenerateMetaClassName(NewClass->m_FullName);
		NewClass->m_RawAttributes	= m_PendingAttributes;
		NewClass->m_AccessQualifier	= GetCurrentAccessQualifier();
		NewClass->m_bAbstract		= false;
		FillTypeLocation(NewClass, Cursor);

		m_PendingAttributes.Empty();

		m_Classes.Add(NewClass);

#if LD_OPT_DUMP_REFLECTION_SCAN_LOG
		LogF(LogTool, LogInfo, "Class: Name=%s, FullName=%s, UUID=%s",
			NewClass->m_Name.ToString().Data(),
			NewClass->m_FullName.ToString().Data(),
			NewClass->m_UUID.ToString().Data()
			);
#endif

		// Cleanup
		clang_disposeString(Name);
		clang_disposeString(USR);

		// Visit all children.
		m_AccessSpecifierStack.Push(bIsStruct ? CX_CXXPublic : CX_CXXPrivate);
		m_ClassStack.Push(NewClass);
		m_SemanticStack.Push(NewClass);

		clang_visitChildren(Cursor, VisitChildNodeThunk, this);

		m_SemanticStack.Pop();
		m_ClassStack.Pop();
		m_AccessSpecifierStack.Pop();
	}
}

void ReflectionFileScanner::VisitAttribute(CXCursor Cursor)
{
	CXString CxName = clang_getCursorSpelling(Cursor);
	CXString CxValue = clang_getCursorDisplayName(Cursor);

	//LogF(LogTool, LogInfo, "Attribute[%s] = %s", clang_getCString(CxName), clang_getCString(CxValue));

	String Value = clang_getCString(CxValue);

	String BuildValue = "";
	int ParentDepth = 0;

	m_PendingAttributes.Empty();

	// Seperate out each attribute defined.
	for (String Chr : Value)
	{
		if (Chr == "(")
		{
			ParentDepth++;
		}
		else if (Chr == ")")
		{
			ParentDepth--;
		}
		else if (Chr == ",")
		{
			if (ParentDepth <= 0)
			{
				m_PendingAttributes.Push(BuildValue.Trim("\t "));
				BuildValue = "";
				continue;
			}
		}

		BuildValue += Chr;
	}

	if (!BuildValue.IsEmpty())
	{
		m_PendingAttributes.Push(BuildValue.Trim("\t "));
	}

	// Fix up attribute names.
	for (String& Str : m_PendingAttributes)
	{
		String::CharIterator LastIter = Str.IndexOf("(");
		String AttributeName = Str.Slice(Str.BeginCharIterator(), LastIter);

		if (!m_KnownClassNames.Contains(AttributeName + "Attribute"))
		{
			WriteError(Cursor, LogError, String::Format("%s:%u: error: Could not find attribute class to instantiate meta-data keyword '%s'. Expected class called '%sAttribute'.", AttributeName.Data(), AttributeName.Data()));
			m_bFailedToCompile = true;
		}

		// Insert Attribute after name, eg DisplayName(...) turns into DisplayNameAttribute(...)
		Str = Str.Insert("Attribute", LastIter);
	}

	clang_disposeString(CxValue);
	clang_disposeString(CxName);
}

void ReflectionFileScanner::WriteError(CXCursor Source, const LogSeverity& Level, const String& Value)
{
	CXFile SourceFile;
	unsigned int SourceLine;
	CXSourceLocation SourceLocation = clang_getCursorLocation(Source);
	clang_getFileLocation(SourceLocation, &SourceFile, &SourceLine, nullptr, nullptr);
	CXString SourceFileString = clang_getFileName(SourceFile);

	String FinalValue = String::Format("%s(%u): %s: %s", clang_getCString(SourceFileString), SourceLine, Level.Name, Value.Data());

	// Make a normal long for the error.
	Log(LogTool, Level, FinalValue.Data());

	// And also print this out seperately so visual studio picks it up as a valid error.
	printf("%s\n", FinalValue.Data());
}

Error ReflectionFileScanner::Scan()
{
	CXIndex Index = clang_createIndex(0, 1);

	Array<const char*> Args;
	for (String& Arg : m_ClangArguments)
	{
		Args.Push(Arg.Data());
	}

	unsigned int flags = CXTranslationUnit_SkipFunctionBodies | CXTranslationUnit_DetailedPreprocessingRecord;

	if (m_TreatAsPch)
	{
		flags |= CXTranslationUnit_ForSerialization;
	}

	CXErrorCode Code = clang_parseTranslationUnit2(
		Index,
		m_SourcePath.ToString().Data(),
		Args.Data(),
		Args.Length(),
		0,
		0,
		flags,
		&m_TranslationUnit);

	if (Code != CXError_Success)
	{
		LogF(LogTool, LogError, "Could not parse translation unit with error 0x%08x for '%s'.", Code, m_OutputPath.ToString().Data());
		clang_disposeIndex(Index);
		return ErrorType::Failure;
	}

	m_bFailedToCompile = false;

	unsigned int DiagnosticCount = clang_getNumDiagnostics(m_TranslationUnit);
	for (unsigned int i = 0; i < DiagnosticCount; i++)
	{
		CXDiagnostic Diagnostic = clang_getDiagnostic(m_TranslationUnit, i);

		CXString Formatted = clang_formatDiagnostic(Diagnostic, 0);

		CXDiagnosticSeverity Severity = clang_getDiagnosticSeverity(Diagnostic);
		if (Severity == CXDiagnostic_Error ||
			Severity == CXDiagnostic_Fatal)
		{
			m_bFailedToCompile = true;
		}

		String Output = clang_getCString(Formatted);

		CXFile SourceFile;
		unsigned int SourceLine;
		CXSourceLocation SourceLocation = clang_getDiagnosticLocation(Diagnostic);
		clang_getFileLocation(SourceLocation, &SourceFile, &SourceLine, nullptr, nullptr);

		CXString SourceFileString = clang_getFileName(SourceFile);

		String FinalValue = String::Format("%s(%u): %s", clang_getCString(SourceFileString), SourceLine, clang_getCString(Formatted));

		// Make a normal long for the error.
		Log(LogTool, LogError, FinalValue.Data());

		// And also print this out seperately so visual studio picks it up as a valid error.
		printf("%s\n", FinalValue.Data());

		clang_disposeString(Formatted);
		clang_disposeDiagnostic(Diagnostic);
	}

	if (!m_bFailedToCompile)
	{
		// Clean up from previous time.
		m_Classes.Empty();

		// Gather all reflection data from AST if we are not doing a PCH build.
		if (!m_TreatAsPch)
		{
			CXCursor TranslationCursor = clang_getTranslationUnitCursor(m_TranslationUnit);
			clang_visitChildren(TranslationCursor, VisitGlobalNodeThunk, this);
		}

		// Store all our dependent files so we know when to rebuild.
		clang_getInclusions(m_TranslationUnit, [] (
				CXFile included_file,
				CXSourceLocation* inclusion_stack,
				unsigned include_len,
				CXClientData client_data
			)
			{
				UNUSED_PARAMETER(include_len);
				UNUSED_PARAMETER(inclusion_stack);

				ReflectionFileScanner* Scanner = reinterpret_cast<ReflectionFileScanner*>(client_data);
				CXString Str = clang_getFileName(included_file);
				Scanner->m_Dependencies.Add(clang_getCString(Str));
				clang_disposeString(Str);
			},
			this);
	}

	// Save out pch if required.
	if (m_TreatAsPch)
	{
		int error = clang_saveTranslationUnit(m_TranslationUnit, m_OutputPath.ToString().Data(), 0);
		if (error != CXSaveError_None)
		{
			LogF(LogTool, LogError, "Failed to save PCH to '%s' with error 0x%08x.", m_OutputPath.ToString().Data(), error);
			m_bFailedToCompile = true;
		}
	}

	// Clean up.
	clang_disposeTranslationUnit(m_TranslationUnit);
	clang_disposeIndex(Index);

	if (m_bFailedToCompile)
	{
		return ErrorType::Failure;
	}
	else
	{
		return ErrorType::Success;
	}
}

void ReflectionFileScanner::WriteMethods(TextStream& Writer, const Array<Method*>& Methods)
{
	for (const Method* Mth : Methods)
	{
		Writer.WriteLine("m_Methods.Add(static_cast<Method*>(TypeOfStatic(%s)));", Mth->m_MetaClassName.ToString().Data());
	}
}

void ReflectionFileScanner::WriteFields(TextStream& Writer, const Array<Field*>& Fields)
{
	for (const Field* Fld : Fields)
	{
		Writer.WriteLine("m_Fields.Add(static_cast<Field*>(TypeOfStatic(%s)));", Fld->m_MetaClassName.ToString().Data());
	}
}

void ReflectionFileScanner::WriteAttributes(TextStream& Writer, const Array<String>& Attributes)
{
	for (String Attr : Attributes)
	{
		String ConstructionArgs = "";

		String::CharIterator OpenParent = Attr.IndexOf("(");
		String::CharIterator CloseParent = Attr.LastIndexOf(")");
		
		if (OpenParent != Attr.EndCharIterator() && 
			CloseParent != Attr.EndCharIterator() &&
			CloseParent > OpenParent + 1)
		{
			ConstructionArgs = Attr.Slice(Attr.BeginCharIterator(), OpenParent);
			ConstructionArgs += ", ";
			ConstructionArgs += Attr.Slice(OpenParent + 1, CloseParent);
		}
		else
		{
			ConstructionArgs = Attr;
		}

		Writer.WriteLine("m_Attributes.Add(LD_ARENA_NEW(ReflectionMemoryArena, %s));", ConstructionArgs.Data());
	}
}

void ReflectionFileScanner::WriteDataType(TextStream& Writer, StringId TypeName, const String& FieldName)
{
	Writer.WriteLine("%s = TypeOfStatic(%s);", FieldName.Data(), TypeName.ToString().Data());
}

void ReflectionFileScanner::WriteParameters(TextStream& Writer, const Array<Parameter>& Parameters)
{
	for (const Parameter& Param : Parameters)
	{
		Writer.WriteLine("m_Parameters.Add(Parameter(TypeOfStatic(%s), StringId::Create(\"%s\")));", Param.DataTypeRawRefRemoved.ToString().Data(), Param.Name.ToString().Data());
	}
}

void ReflectionFileScanner::WriteTypeInit(TextStream& Writer, Type* Value)
{
	Writer.WriteLine("m_Name = StringId::Create(\"%s\");", Value->m_Name.ToString().Data());
	Writer.WriteLine("m_FullName = StringId::Create(\"%s\");", Value->m_FullName.ToString().Data());
	Writer.WriteLine("m_UUID = StringId::Create(\"%s\");", Value->m_UUID.ToString().Data());
	Writer.WriteLine("m_MetaClassName = StringId::Create(\"%s\");", Value->m_MetaClassName.ToString().Data());

	if (Value->m_AccessQualifier == TypeAccessQualifier::Public)
	{
		Writer.WriteLine("m_AccessQualifier = TypeAccessQualifier::Public;");
	}
	else if (Value->m_AccessQualifier == TypeAccessQualifier::Protected)
	{
		Writer.WriteLine("m_AccessQualifier = TypeAccessQualifier::Protected;");
	}
	else if (Value->m_AccessQualifier == TypeAccessQualifier::Private)
	{
		Writer.WriteLine("m_AccessQualifier = TypeAccessQualifier::Private;");
	}
	Writer.WriteLine("m_FileName = StringId::Create(\"%s\");", Value->m_FileName.ToString().Escape().Data());
	Writer.WriteLine("m_Line = %i;", Value->m_Line);
}

Error ReflectionFileScanner::Save()
{
//	LogF(LogTool, LogInfo, "Saving: %s", m_OutputPath.ToString().Data());

	// Dump out dependencies.
	File DependencyOutputFile;
	Error Result = DependencyOutputFile.Open(m_DependentsOutputPath, FileFlags::Write);
	if (Result.Succeeded())
	{
		TextStream Writer(&DependencyOutputFile);
		for (String& DependencyPath : m_Dependencies)
		{
			Writer.WriteLine("%s", DependencyPath.Data());
		}
	}

	// Dump into metadata file.
	File OutputFile;
	Result = OutputFile.Open(m_OutputPath, FileFlags::Write);
	if (Result.Succeeded())
	{		
		Path RelativeSourcePath = m_OutputPath.RelativeTo(m_SourcePath);

		TextStream Writer(&OutputFile);

		Writer.WriteLine("/*");
		Writer.WriteLine("Ludo Game Engine");
		Writer.WriteLine("Copyright (C) 2016 TwinDrills");
		Writer.WriteLine("");
		Writer.WriteLine("This program is free software: you can redistribute it and/or modify");
		Writer.WriteLine("it under the terms of the GNU General Public License as published by");
		Writer.WriteLine("the Free Software Foundation, either version 3 of the License, or");
		Writer.WriteLine("(at your option) any later version.");
		Writer.WriteLine("");
		Writer.WriteLine("This program is distributed in the hope that it will be useful,");
		Writer.WriteLine("but WITHOUT ANY WARRANTY; without even the implied warranty of");
		Writer.WriteLine("MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the");
		Writer.WriteLine("GNU General Public License for more details.");
		Writer.WriteLine("");
		Writer.WriteLine("You should have received a copy of the GNU General Public License");
		Writer.WriteLine("along with this program.  If not, see <http://www.gnu.org/licenses/>.");
		Writer.WriteLine("*/");
		Writer.WriteLine("");
		Writer.WriteLine("// Warning:");
		Writer.WriteLine("//   This file is automatically generated. Do not modify directly, instead");
		Writer.WriteLine("//   change the source file or modify the code in ReflectionFileScanner.cpp.");
		Writer.WriteLine("//   Any changes you make will be lost on the next build.");
		Writer.WriteLine("");
		Writer.WriteLine("#include \"Core/Reflection/ReflectionInternal.h\"");
		Writer.WriteLine("#include \"%s\"", RelativeSourcePath.ToString().Data());
		Writer.WriteLine("");
		Writer.WriteLine("namespace Ludo {");
		Writer.WriteLine("namespace Meta {");
		Writer.WriteLine("");

		// Write out forward-declarations.
		for (Class* Cls : m_Classes)
		{
			Writer.WriteLine("class %s;", Cls->m_MetaClassName.ToString().Data());
		}
		Writer.WriteLine("");

		// Generate method meta data.
		for (Method* Mth : m_Methods)
		{
			String ArgumentTypeString = "";
			for (Parameter& Param : Mth->m_Parameters)
			{
				if (!ArgumentTypeString.IsEmpty())
				{
					ArgumentTypeString += ", ";
				}
				ArgumentTypeString += Param.DataTypeRaw.ToString();
			}

			// Access-right bypass boilerplate
			if (!Mth->m_bConstructor)
			{
				Writer.WriteLine("");

				if (!Mth->m_bStatic)
				{
					Writer.WriteLine("struct %s_AccessTag : BypassAccessRightsTag<%s_AccessTag, %s (%s::*)(%s) %s> { };", Mth->m_MetaClassName.ToString().Data(), Mth->m_MetaClassName.ToString().Data(), Mth->m_ReturnTypeRaw.ToString().Data(), Mth->m_ClassNameRaw.ToString().Data(), ArgumentTypeString.Data(), Mth->m_bConst ? "const" : "");
				}
				else
				{
					Writer.WriteLine("struct %s_AccessTag : BypassAccessRightsTag<%s_AccessTag, %s (*)(%s)> { };", Mth->m_MetaClassName.ToString().Data(), Mth->m_MetaClassName.ToString().Data(), Mth->m_ReturnTypeRaw.ToString().Data(), ArgumentTypeString.Data());
				}
				Writer.WriteLine("template struct BypassAccessRights<%s_AccessTag, &%s::%s>;", Mth->m_MetaClassName.ToString().Data(), Mth->m_ClassNameRaw.ToString().Data(), Mth->m_Name.ToString().Data());
				Writer.WriteLine("");
			}

			Writer.WriteLine("class %s : public Method", Mth->m_MetaClassName.ToString().Data());
			Writer.WriteLine("{");
			Writer.WriteLine("public:");
			Writer.Indent();

				Writer.WriteLine("%s()", Mth->m_MetaClassName.ToString().Data());
				Writer.WriteLine("{");
				Writer.Indent();
					WriteTypeInit(Writer, Mth);
					Writer.WriteLine("m_bConstructor = %s;", Mth->m_bConstructor ? "true" : "false");
					Writer.WriteLine("m_bStatic = %s;", Mth->m_bStatic ? "true" : "false");
					Writer.WriteLine("m_bConst = %s;", Mth->m_bConst ? "true" : "false");
					Writer.WriteLine("m_bVirtual = %s;", Mth->m_bVirtual ? "true" : "false");
					Writer.WriteLine("m_bPureVirtual = %s;", Mth->m_bPureVirtual ? "true" : "false");
					Writer.Undent();
				Writer.WriteLine("}");

				Writer.WriteLine("");

				Writer.WriteLine("virtual void OnPostRegistration() override");
				Writer.WriteLine("{");
				Writer.Indent();
					WriteParameters(Writer, Mth->m_Parameters);
					WriteDataType(Writer, Mth->m_ReturnTypeRaw, "m_ReturnType");
					WriteAttributes(Writer, Mth->m_RawAttributes);
				Writer.Undent();
				Writer.WriteLine("}");

				Writer.WriteLine("");

				// Welcome to ugly hack town, population you.
				// The invokation code generated is even worse than the setter-getters for fields, cover your eyes.

				Writer.WriteLine("virtual void InvokeInternal(void* Instance, void* Result, Array<void*>& Parameters) override");
				Writer.WriteLine("{");
				Writer.Indent();	
				
					Writer.WriteLine("%s* ClassInstance = reinterpret_cast<%s*>(Instance);", Mth->m_ClassNameRaw.ToString().Data(), Mth->m_ClassNameRaw.ToString().Data());

					if (Mth->m_bConstructor)
					{
						Writer.WriteLine("*reinterpret_cast<%s**>(Result) = new(Instance) %s(", Mth->m_ClassNameRaw.ToString().Data(), Mth->m_ClassNameRaw.ToString().Data());
					}
					else
					{
						if (Mth->m_bStatic)
						{
							if (Mth->m_ReturnTypeRaw.ToString() == "void")
							{
								Writer.WriteLine("(Get(%s_AccessTag()))(", Mth->m_MetaClassName.ToString().Data());
							}
							else
							{
								Writer.WriteLine("*reinterpret_cast<%s*>(Result) = (Get(%s_AccessTag()))(", Mth->m_ReturnTypeRawRefRemoved.ToString().Data(), Mth->m_MetaClassName.ToString().Data());
							}
						}
						else
						{
							if (Mth->m_ReturnTypeRaw.ToString() == "void")
							{
								Writer.WriteLine("(ClassInstance->*Get(%s_AccessTag()))(", Mth->m_MetaClassName.ToString().Data());
							}
							else
							{
								Writer.WriteLine("*reinterpret_cast<%s*>(Result) = (ClassInstance->*Get(%s_AccessTag()))(", Mth->m_ReturnTypeRawRefRemoved.ToString().Data(), Mth->m_MetaClassName.ToString().Data());
							}
						}
					}
					Writer.Indent();

					int ParamIndex = 0;
					for (Parameter& Param : Mth->m_Parameters)
					{
						Writer.WriteLine("*reinterpret_cast<%s*>(Parameters[%i])%s", Param.DataTypeRawRefRemoved.ToString().Data(), ParamIndex, ParamIndex < Mth->m_Parameters.Length() - 1 ? "," : "");
						ParamIndex++;
					}

					Writer.Undent();
					Writer.WriteLine(");");

				Writer.Undent();
				Writer.WriteLine("}");

			Writer.Undent();
			Writer.WriteLine("};");
			Writer.WriteLine("");
		}

		// Generate field meta data.
		for (Field* Fld : m_Fields)
		{			
			Writer.WriteLine("");
			if (!Fld->m_bStatic)
			{
				Writer.WriteLine("struct %s_AccessTag : BypassAccessRightsTag<%s_AccessTag, %s %s::*> { };", Fld->m_MetaClassName.ToString().Data(), Fld->m_MetaClassName.ToString().Data(), Fld->m_DataTypeRaw.ToString().Data(), Fld->m_ClassNameRaw.ToString().Data());
			}
			else
			{
				Writer.WriteLine("struct %s_AccessTag : BypassAccessRightsTag<%s_AccessTag, %s*> { };", Fld->m_MetaClassName.ToString().Data(), Fld->m_MetaClassName.ToString().Data(), Fld->m_DataTypeRaw.ToString().Data(), Fld->m_ClassNameRaw.ToString().Data());
			}
			Writer.WriteLine("template struct BypassAccessRights<%s_AccessTag, &%s::%s>;", Fld->m_MetaClassName.ToString().Data(), Fld->m_ClassNameRaw.ToString().Data(), Fld->m_Name.ToString().Data());
			Writer.WriteLine("");
			Writer.WriteLine("class %s : public Field", Fld->m_MetaClassName.ToString().Data());
			Writer.WriteLine("{");
			Writer.WriteLine("public:");
			Writer.Indent();

				Writer.WriteLine("%s()", Fld->m_MetaClassName.ToString().Data());
				Writer.WriteLine("{");
				Writer.Indent();
					WriteTypeInit(Writer, Fld);
					Writer.WriteLine("m_bStatic = %s;", Fld->m_bStatic ? "true" : "false");
					Writer.WriteLine("m_bConst = %s;", Fld->m_bConst ? "true" : "false");		
					Writer.Undent();
				Writer.WriteLine("}");

				Writer.WriteLine("");

				Writer.WriteLine("virtual void OnPostRegistration() override");
				Writer.WriteLine("{");
				Writer.Indent();
					WriteDataType(Writer, Fld->m_DataTypeRaw, "m_DataType");
					WriteAttributes(Writer, Fld->m_RawAttributes);
				Writer.Undent();
				Writer.WriteLine("}");

				Writer.WriteLine("");

				// Welcome to ugly hack town, population you.
				// The setters and getters here do some crazy template shenanigans to ignore access specifiers.
				// This is definitely something you should never normally do -_-.

				Writer.WriteLine("virtual void SetInternal(void* Instance, void* Data) override");
				Writer.WriteLine("{");
				Writer.Indent();
				if (Fld->m_bConst)
				{
					Writer.WriteLine("ConstantAssertMsg(\"Attempt to set value of const value by reflection.\");");
				}
				else
				{
					Writer.WriteLine("%s* ClassInstance = reinterpret_cast<%s*>(Instance);", Fld->m_ClassNameRaw.ToString().Data(), Fld->m_ClassNameRaw.ToString().Data());
					if (Fld->m_bStatic)
					{
						Writer.WriteLine("*Get(%s_AccessTag()) = *reinterpret_cast<%s*>(Data);", Fld->m_MetaClassName.ToString().Data(), Fld->m_DataTypeRawRefRemoved.ToString().Data());
					}
					else
					{
						Writer.WriteLine("ClassInstance->*Get(%s_AccessTag()) = *reinterpret_cast<%s*>(Data);", Fld->m_MetaClassName.ToString().Data(), Fld->m_DataTypeRawRefRemoved.ToString().Data());
					}
				}
				Writer.Undent();
				Writer.WriteLine("}");
					
				Writer.WriteLine("");

				Writer.WriteLine("virtual void GetInternal(void* Instance, void* Data) override");
				Writer.WriteLine("{");
				Writer.Indent();
					Writer.WriteLine("%s* ClassInstance = reinterpret_cast<%s*>(Instance);", Fld->m_ClassNameRaw.ToString().Data(), Fld->m_ClassNameRaw.ToString().Data());

					String DataType = Fld->m_DataTypeRawRefRemoved.ToString();
					if (Fld->m_bConst)
					{
						DataType = DataType.Replace("const", "");
					}

					if (Fld->m_bStatic)
					{
						Writer.WriteLine("*reinterpret_cast<%s*>(Data) = *Get(%s_AccessTag());", DataType.Data(), Fld->m_MetaClassName.ToString().Data());
					}
					else
					{
						Writer.WriteLine("*reinterpret_cast<%s*>(Data) = ClassInstance->*Get(%s_AccessTag());", DataType.Data(), Fld->m_MetaClassName.ToString().Data());
					}
				Writer.Undent();
				Writer.WriteLine("}");

			Writer.Undent();
			Writer.WriteLine("};");
			Writer.WriteLine("");
		}

		// Generate class meta data.
		for (Class* Cls : m_Classes)
		{
			Writer.WriteLine("class %s : public Class", Cls->m_MetaClassName.ToString().Data());
			Writer.WriteLine("{");
			Writer.WriteLine("public:");
			Writer.Indent();

				Writer.WriteLine("%s()", Cls->m_MetaClassName.ToString().Data());
				Writer.WriteLine("{");
				Writer.Indent();
					WriteTypeInit(Writer, Cls);
					Writer.WriteLine("m_TypeInfoName = StringId::Create(typeid(%s).name());", Cls->m_FullName.ToString().Data());
					Writer.WriteLine("m_bAbstract = %s;", Cls->m_bAbstract ? "true" : "false");
				Writer.Undent();
				Writer.WriteLine("}");

				Writer.WriteLine("");

				Writer.WriteLine("virtual void OnPostRegistration() override");
				Writer.WriteLine("{");
				Writer.Indent();					
					WriteMethods(Writer, Cls->m_Methods);
					WriteFields(Writer, Cls->m_Fields);
					WriteAttributes(Writer, Cls->m_RawAttributes);

					for (StringId& BaseName : Cls->m_BaseClassesRaw)
					{
						Writer.WriteLine("m_BaseClasses.Append(TypeOfStatic(%s));", BaseName.ToString().Data());
					}
				Writer.Undent();
				Writer.WriteLine("}");

				Writer.WriteLine("");

				Writer.WriteLine("virtual void OnBuildClassTree() override");
				Writer.WriteLine("{");
				Writer.Indent();
					Writer.WriteLine("m_DerivedClasses = Type::GetDerivedClasses(this);");
				Writer.Undent();
				Writer.WriteLine("}");

				Writer.WriteLine("");

				Writer.WriteLine("virtual void* NewInstance(IAllocator* Allocator) override");
				Writer.WriteLine("{");
				Writer.Indent();
					Writer.WriteLine("return Allocator->Alloc(sizeof(%s));", Cls->m_FullName.ToString().Data());
				Writer.Undent();
				Writer.WriteLine("}");

			Writer.Undent();
			Writer.WriteLine("};");
			Writer.WriteLine("");
		}
		
		// Generate enum meta data.
		for (Enum* Cls : m_Enums)
		{
			Writer.WriteLine("class %s : public Enum", Cls->m_MetaClassName.ToString().Data());
			Writer.WriteLine("{");
			Writer.WriteLine("public:");
			Writer.Indent();

				Writer.WriteLine("%s()", Cls->m_MetaClassName.ToString().Data());
				Writer.WriteLine("{");
				Writer.Indent();
					WriteTypeInit(Writer, Cls);
					Writer.WriteLine("m_TypeInfoName = StringId::Create(typeid(%s).name());", Cls->m_FullName.ToString().Data());
					for (EnumKey& Key : Cls->m_Keys)
					{
						Writer.WriteLine("m_Keys.Add(EnumKey(this, StringId::Create(\"%s\"), %lld));", Key.m_Name.ToString().Escape().Data(), Key.m_Value);
					}
				Writer.Undent();
				Writer.WriteLine("}");

			Writer.Undent();
			Writer.WriteLine("};");
			Writer.WriteLine("");
		}

		Writer.WriteLine("void RegisterTypes_%s()", m_FileId.Data());
		Writer.WriteLine("{");
		Writer.Indent();

			for (Method* Mth : m_Methods)
			{
				Writer.WriteLine("Type::RegisterType<%s>();", Mth->m_MetaClassName.ToString().Data());
			}
			for (Field* Fld : m_Fields)
			{
				Writer.WriteLine("Type::RegisterType<%s>();", Fld->m_MetaClassName.ToString().Data());
			}
			for (Class* Cls : m_Classes)
			{
				Writer.WriteLine("Type::RegisterType<%s>();", Cls->m_MetaClassName.ToString().Data());
			}
			for (Enum* Cls : m_Enums)
			{
				Writer.WriteLine("Type::RegisterType<%s>();", Cls->m_MetaClassName.ToString().Data());
			}

		Writer.Undent();
		Writer.WriteLine("}");
		Writer.WriteLine("");
		Writer.WriteLine("void UnregisterTypes_%s()", m_FileId.Data());
		Writer.WriteLine("{");
		Writer.Indent();

		for (Method* Mth : m_Methods)
		{
			Writer.WriteLine("Type::UnregisterType<%s>();", Mth->m_MetaClassName.ToString().Data());
		}
		for (Field* Fld : m_Fields)
		{
			Writer.WriteLine("Type::UnregisterType<%s>();", Fld->m_MetaClassName.ToString().Data());
		}
		for (Class* Cls : m_Classes)
		{
			Writer.WriteLine("Type::UnregisterType<%s>();", Cls->m_MetaClassName.ToString().Data());
		}

		Writer.Undent();
		Writer.WriteLine("}");
		Writer.WriteLine("");
		Writer.WriteLine("} // namespace Meta");
		Writer.WriteLine("} // namespace Ludo");

		Writer.Flush();
		OutputFile.Close();

		return ErrorType::Success;
	}
	else
	{
		LogF(LogTool, LogError, "Could not open stream to file '%s'.", m_OutputPath.ToString().Data());
	}

	return ErrorType::Failure;
}

}; // namespace Ludo
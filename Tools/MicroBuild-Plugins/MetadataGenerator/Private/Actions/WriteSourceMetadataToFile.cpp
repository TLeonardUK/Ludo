/*
MicroBuild
Copyright (C) 2016 TwinDrills

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "PCH.h"

#include "Actions/WriteSourceMetadataToFile.h"

namespace MicroBuild {
	
WriteSourceMetadataToFile::WriteSourceMetadataToFile(MetadataFileInfo& info, ProjectFile& project)
	: m_fileInfo(info)
	, m_project(project)
{
	m_fileId = Strings::Uuid(16, { m_fileInfo.GeneratedHeaderPath.ToString() });
}

void WriteSourceMetadataToFile::WriteHeader(TextStream& stream)
{

	Platform::Path relativePath = m_fileInfo.RootDirectory.RelativeTo(m_fileInfo.SourcePath);

	stream.WriteLine("/*");
	stream.WriteLine("Ludo Game Engine");
	stream.WriteLine("Copyright (C) 2016 TwinDrills");
	stream.WriteLine("");
	stream.WriteLine("This program is free software: you can redistribute it and/or modify");
	stream.WriteLine("it under the terms of the GNU General Public License as published by");
	stream.WriteLine("the Free Software Foundation, either version 3 of the License, or");
	stream.WriteLine("(at your option) any later version.");
	stream.WriteLine("");
	stream.WriteLine("This program is distributed in the hope that it will be useful,");
	stream.WriteLine("but WITHOUT ANY WARRANTY; without even the implied warranty of");
	stream.WriteLine("MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the");
	stream.WriteLine("GNU General Public License for more details.");
	stream.WriteLine("");
	stream.WriteLine("You should have received a copy of the GNU General Public License");
	stream.WriteLine("along with this program.  If not, see <http://www.gnu.org/licenses/>.");
	stream.WriteLine("*/");
	stream.WriteLine("");
	if (!m_project.Get_Build_PrecompiledHeader().IsEmpty())
	{
		stream.WriteLine("#include \"%s\"", m_project.Get_Build_PrecompiledHeader().GetFilename().c_str());
	}
	stream.WriteLine("#include \"Core/Public/Reflection/Reflection.h\"");
	stream.WriteLine("#include \"%s\"", relativePath.ToString().c_str());
	stream.WriteLine("");
	stream.WriteLine("// Warning: This file is automatically generated by the MetaGeneration plugin.");
	stream.WriteLine("//          Do not modify manually, any change you make will not survive the next build.");
	stream.WriteLine("");
	stream.WriteLine("namespace Ludo {");
	stream.WriteLine("");
}

void WriteSourceMetadataToFile::WriteFooter(TextStream& stream)
{
	stream.WriteLine("");
	stream.WriteLine("}; // namespace Ludo");
}

void WriteSourceMetadataToFile::WriteBaseRecordConstructor(TextStream& stream, MetadataObject::Ptr objectPtr)
{
	stream.WriteLine("m_Name = StringId::Create(%s);", Strings::Quoted(objectPtr->Name).c_str());
	stream.WriteLine("m_FullyQualifiedName = StringId::Create(%s);", Strings::Quoted(objectPtr->FullyQualifiedName).c_str());
	stream.WriteLine("m_MangledName = StringId::Create(%s);", Strings::Quoted(objectPtr->MangledName).c_str());
	stream.WriteLine("");
	stream.WriteLine("m_Location.File = StringId::Create(%s);", Strings::Quoted(objectPtr->Location.FileName, true).c_str());
	stream.WriteLine("m_Location.Column = %i;", objectPtr->Location.Column);
	stream.WriteLine("m_Location.Line = %i;", objectPtr->Location.Line);
	stream.WriteLine("");
	for (auto& attr : objectPtr->Attributes)
	{
		// Skip dummy attributes.
		if (attr.Name == "MetadataTag")
		{
			continue;
		}

		stream.Write("m_Attributes.Add(LD_ARENA_NEW(ReflectionMemoryArena, %sAttribute", attr.Name.c_str());
		for (auto& value : attr.Values)
		{
			stream.WriteRaw(", %s", value.c_str());
		}
		stream.WriteRaw("));");
		stream.WriteNewLine();
	}
}

std::string WriteSourceMetadataToFile::MakeTypeCreation(MetadataType::Ptr type)
{
	std::string result = "";

	switch (type->PrimitiveType)
	{	
	case MetadataPrimitiveType::Pointer:
		{
			result = Strings::Format("Type::Find(TypePrimitive::Pointer, %s, %s)", MakeTypeCreation(type->PointerType).c_str(), type->IsConst ? "true" : "false");
			break;
		}
	case MetadataPrimitiveType::LValueReference:
		{
			result = Strings::Format("Type::Find(TypePrimitive::LValueReference, %s, %s)", MakeTypeCreation(type->PointerType).c_str(), type->IsConst ? "true" : "false");
			break;
		}
	case MetadataPrimitiveType::RValueReference:
		{
			result = Strings::Format("Type::Find(TypePrimitive::RValueReference, %s, %s)", MakeTypeCreation(type->PointerType).c_str(), type->IsConst ? "true" : "false");
			break;
		}
	case MetadataPrimitiveType::Class:
		{
			result = Strings::Format("Type::Find(TypePrimitive::Class, Record::FindByNameAndType<Class>(%s), %s)", Strings::Quoted(type->Class->FullyQualifiedName).c_str(), type->IsConst ? "true" : "false");
			break;
		}
	case MetadataPrimitiveType::Enum:
		{
			result = Strings::Format("Type::Find(TypePrimitive::Enum, Record::FindByNameAndType<Enum>(%s), %s)", Strings::Quoted(type->Enum->FullyQualifiedName).c_str(), type->IsConst ? "true" : "false");
			break;
		}
	case MetadataPrimitiveType::Void:
		{
			result = Strings::Format("Type::Find(TypePrimitive::Void, %s)", type->IsConst ? "true" : "false");
			break;
		}
	case MetadataPrimitiveType::Bool:
		{
			result = Strings::Format("Type::Find(TypePrimitive::Bool, %s)", type->IsConst ? "true" : "false");
			break;
		}
	case MetadataPrimitiveType::Int8:
		{
			result = Strings::Format("Type::Find(TypePrimitive::Int8, %s)", type->IsConst ? "true" : "false");
			break;
		}
	case MetadataPrimitiveType::Int16:
		{
			result = Strings::Format("Type::Find(TypePrimitive::Int16, %s)", type->IsConst ? "true" : "false");
			break;
		}
	case MetadataPrimitiveType::Int32:
		{
			result = Strings::Format("Type::Find(TypePrimitive::Int32, %s)", type->IsConst ? "true" : "false");
			break;
		}
	case MetadataPrimitiveType::Int64:
		{
			result = Strings::Format("Type::Find(TypePrimitive::Int64, %s)", type->IsConst ? "true" : "false");
			break;
		}
	case MetadataPrimitiveType::UInt8:
		{
			result = Strings::Format("Type::Find(TypePrimitive::UInt8, %s)", type->IsConst ? "true" : "false");
			break;
		}
	case MetadataPrimitiveType::UInt16:
		{
			result = Strings::Format("Type::Find(TypePrimitive::UInt16, %s)", type->IsConst ? "true" : "false");
			break;
		}
	case MetadataPrimitiveType::UInt32:
		{
			result = Strings::Format("Type::Find(TypePrimitive::UInt32, %s)", type->IsConst ? "true" : "false");
			break;
		}
	case MetadataPrimitiveType::UInt64:
		{
			result = Strings::Format("Type::Find(TypePrimitive::UInt64, %s)", type->IsConst ? "true" : "false");
			break;
		}
	case MetadataPrimitiveType::Float:
		{
			result = Strings::Format("Type::Find(TypePrimitive::Float, %s)", type->IsConst ? "true" : "false");
			break;
		}
	case MetadataPrimitiveType::Double:
		{
			result = Strings::Format("Type::Find(TypePrimitive::Double, %s)", type->IsConst ? "true" : "false");
			break;
		}
	default:
		{
            assert(false);
			break;
		}
	}

	return result;
}

void WriteSourceMetadataToFile::WriteClass(TextStream& stream, MetadataClass::Ptr classPtr)
{
	stream.WriteLine("// ----------------------------------------------------------------------------");
	stream.WriteLine("// Class - %s", classPtr->FullyQualifiedName.c_str());
	stream.WriteLine("// ----------------------------------------------------------------------------");	
	stream.WriteLine("class %s : public Class", classPtr->SanitizedName.c_str());
	stream.WriteLine("{");
	stream.WriteLine("public:");
	stream.Indent();

		// Constructor.
		stream.WriteLine("%s()", classPtr->SanitizedName.c_str());
		stream.WriteLine("{");
		stream.Indent();
			WriteBaseRecordConstructor(stream, classPtr);
			stream.WriteLine("m_bAbstract = %s;", classPtr->IsAbstract ? "true" : "false");
			stream.WriteLine("m_bStruct = %s;", classPtr->IsStruct ? "true" : "false");
			stream.WriteLine("m_bTemplate = %s;", classPtr->IsTemplated ? "true" : "false");
			stream.WriteLine("m_bTemplateInstance = %s;", classPtr->IsTemplateInstance ? "true" : "false");
		stream.Undent();
		stream.WriteLine("}");

	stream.Undent();
	stream.WriteLine("protected:");
	stream.Indent();

		// Post-Registration.
		stream.WriteLine("virtual void OnPostRegistration() override");
		stream.WriteLine("{");
		stream.Indent();		
			for (auto& cls : classPtr->BaseClasses)
			{ 
				stream.WriteLine("m_BaseClasses.Add(Record::FindByNameAndType<Class>(StringId::Create(%s)));", Strings::Quoted(cls.Class->FullyQualifiedName).c_str());
			}
			for (auto& mth : classPtr->Methods)
			{ 
				stream.WriteLine("m_Methods.Add(Record::FindByNameAndType<Method>(StringId::Create(%s)));", Strings::Quoted(mth->FullyQualifiedName).c_str());
			}
			for (auto& fld : classPtr->Fields)
			{ 
				stream.WriteLine("m_Fields.Add(Record::FindByNameAndType<Field>(StringId::Create(%s)));", Strings::Quoted(fld->FullyQualifiedName).c_str());
			}
			if (classPtr->IsTemplated && classPtr->IsTemplateInstance)
			{
				for (auto& param : classPtr->TemplateTypes)
				{
					switch (param.BaseType)
					{
					case EMetadataTemplateBaseType::Integer:
						{
							stream.WriteLine("m_TemplateParameters.Add(ClassTemplateParameter(EClassTemplateParameterType::Integer, %llu, nullptr));", param.Value);
							break;
						}
					case EMetadataTemplateBaseType::Type:
						{
							stream.WriteLine("m_TemplateParameters.Add(ClassTemplateParameter(EClassTemplateParameterType::Type, 0, %s));", MakeTypeCreation(param.Type).c_str());
							break;
						}
					}
				}
			}
		stream.Undent();
		stream.WriteLine("}");

	stream.Undent();

	stream.WriteLine("};");
	stream.WriteLine("");

	for (auto& method : classPtr->Methods)
	{
		WriteMethod(stream, classPtr, method);
	}

	for (auto& field : classPtr->Fields)
	{
		WriteField(stream, classPtr, field);
	}
}

void WriteSourceMetadataToFile::WriteMethod(TextStream& stream, MetadataClass::Ptr classPtr, MetadataMethod::Ptr methodPtr)
{	
	stream.WriteLine("class %s : public Method", methodPtr->SanitizedName.c_str());
	stream.WriteLine("{");
	stream.WriteLine("public:");
	stream.Indent();

		// Constructor.
		stream.WriteLine("%s()", methodPtr->SanitizedName.c_str());
		stream.WriteLine("{");
		stream.Indent();
			WriteBaseRecordConstructor(stream, methodPtr);
			stream.WriteLine("m_bConstructor = %s;", methodPtr->IsConstructor ? "true" : "false");
			stream.WriteLine("m_bStatic = %s;", methodPtr->IsStatic ? "true" : "false");
			stream.WriteLine("m_bConst = %s;", methodPtr->IsConst ? "true" : "false");
			stream.WriteLine("m_bVirtual = %s;", methodPtr->IsVirtual ? "true" : "false");
			stream.WriteLine("m_bPureVirtual = %s;", methodPtr->IsAbstract ? "true" : "false");
		stream.Undent();
		stream.WriteLine("}");

	stream.Undent();
	stream.WriteLine("protected:");
	stream.Indent();

		// Post-Registration.
		stream.WriteLine("virtual void OnPostRegistration() override");
		stream.WriteLine("{");
		stream.Indent();		
			stream.WriteLine("m_Class = Record::FindByNameAndType<Class>(StringId::Create(%s));", Strings::Quoted(classPtr->FullyQualifiedName).c_str());
			stream.WriteLine("m_ReturnType = %s;", MakeTypeCreation(methodPtr->ReturnType).c_str());
			for (auto& param : methodPtr->Parameters)
			{
				stream.WriteLine("m_Parameters.Add(Record::FindByNameAndType<Parameter>(StringId::Create(%s)));", Strings::Quoted(param->FullyQualifiedName).c_str());
			}
		stream.Undent();
		stream.WriteLine("}");

	stream.Undent();

	stream.WriteLine("};");
	stream.WriteLine("");

	for (auto& param : methodPtr->Parameters)
	{
		WriteParameter(stream, methodPtr, param);
	}
}

void WriteSourceMetadataToFile::WriteParameter(TextStream& stream, MetadataMethod::Ptr methodPtr, MetadataParameter::Ptr parameterPtr)
{
	stream.WriteLine("class %s : public Parameter", parameterPtr->SanitizedName.c_str());
	stream.WriteLine("{");
	stream.WriteLine("public:");
	stream.Indent();

		// Constructor.
		stream.WriteLine("%s()", parameterPtr->SanitizedName.c_str());
		stream.WriteLine("{");
		stream.Indent();
			WriteBaseRecordConstructor(stream, parameterPtr);
		stream.Undent();
		stream.WriteLine("}");

	stream.Undent();
	stream.WriteLine("protected:");
	stream.Indent();

		// Post-Registration.
		stream.WriteLine("virtual void OnPostRegistration() override");
		stream.WriteLine("{");
		stream.Indent();		
			stream.WriteLine("m_DataType = %s;", MakeTypeCreation(parameterPtr->Type).c_str());
		stream.Undent();
		stream.WriteLine("}");

	stream.Undent();

	stream.WriteLine("};");
	stream.WriteLine("");
}

void WriteSourceMetadataToFile::WriteField(TextStream& stream, MetadataClass::Ptr classPtr, MetadataField::Ptr fieldPtr)
{
	stream.WriteLine("class %s : public Field", fieldPtr->SanitizedName.c_str());
	stream.WriteLine("{");
	stream.WriteLine("public:");
	stream.Indent();

		// Constructor.
		stream.WriteLine("%s()", fieldPtr->SanitizedName.c_str());
		stream.WriteLine("{");
		stream.Indent();
			WriteBaseRecordConstructor(stream, fieldPtr);
			stream.WriteLine("m_bStatic = %s;", fieldPtr->IsStatic ? "true" : "false");
		stream.Undent();
		stream.WriteLine("}");

	stream.Undent();
	stream.WriteLine("protected:");
	stream.Indent();

		// Post-Registration.
		stream.WriteLine("virtual void OnPostRegistration() override");
		stream.WriteLine("{");
		stream.Indent();		
			stream.WriteLine("m_DataType = %s;", MakeTypeCreation(fieldPtr->Type).c_str());
		stream.Undent();
		stream.WriteLine("}");

	stream.Undent();

	stream.WriteLine("};");
	stream.WriteLine("");
}

void WriteSourceMetadataToFile::WriteEnum(TextStream& stream, MetadataEnum::Ptr enumPtr)
{
	stream.WriteLine("// ----------------------------------------------------------------------------");
	stream.WriteLine("// Enum - %s", enumPtr->FullyQualifiedName.c_str());
	stream.WriteLine("// ----------------------------------------------------------------------------");
	stream.WriteLine("class %s : public Enum", enumPtr->SanitizedName.c_str());
	stream.WriteLine("{");
	stream.WriteLine("public:");
	stream.Indent();

		// Constructor.
		stream.WriteLine("%s()", enumPtr->SanitizedName.c_str());
		stream.WriteLine("{");
		stream.Indent();
			WriteBaseRecordConstructor(stream, enumPtr);
		stream.Undent();
		stream.WriteLine("}");

	stream.Undent();
	stream.WriteLine("protected:");
	stream.Indent();

		// Post-Registration.
		stream.WriteLine("virtual void OnPostRegistration() override");
		stream.WriteLine("{");
		stream.Indent();		
			for (auto& key : enumPtr->Keys)
			{ 
				stream.WriteLine("m_Keys.Add(Record::FindByNameAndType<EnumKey>(StringId::Create(%s)));", Strings::Quoted(key->FullyQualifiedName).c_str());
			}
		stream.Undent();
		stream.WriteLine("}");

	stream.Undent();

	stream.WriteLine("};");
	stream.WriteLine("");

	for (auto& key : enumPtr->Keys)
	{
		WriteEnumKey(stream, enumPtr, key);
	}
}

void WriteSourceMetadataToFile::WriteEnumKey(TextStream& stream, MetadataEnum::Ptr enumPtr, MetadataEnumKey::Ptr key)
{
	stream.WriteLine("class %s : public EnumKey", key->SanitizedName.c_str());
	stream.WriteLine("{");
	stream.WriteLine("public:");
	stream.Indent();

		// Constructor.
		stream.WriteLine("%s()", key->SanitizedName.c_str());
		stream.WriteLine("{");
		stream.Indent();
			WriteBaseRecordConstructor(stream, key);
			stream.WriteLine("m_Value = %llu;", key->Constant);
		stream.Undent();
		stream.WriteLine("}");

	stream.Undent();
	stream.WriteLine("protected:");
	stream.Indent();

		// Post-Registration.
		stream.WriteLine("virtual void OnPostRegistration() override");
		stream.WriteLine("{");
		stream.Indent();
			stream.WriteLine("m_Enum = Record::FindByNameAndType<Enum>(StringId::Create(%s));", Strings::Quoted(enumPtr->FullyQualifiedName).c_str());
		stream.Undent();
		stream.WriteLine("}");

	stream.Undent();

	stream.WriteLine("};");
	stream.WriteLine("");
}

void WriteSourceMetadataToFile::WriteRegistration(TextStream& stream)
{
	std::vector<std::string> typeIds;

	for (auto& classPtr : m_fileInfo.Module.Classes)
	{
		if (classPtr->InMainFile && (!classPtr->IsTemplated || classPtr->IsTemplateInstance))
		{
			typeIds.push_back(classPtr->SanitizedName);

			for (auto& method : classPtr->Methods)
			{
				typeIds.push_back(method->SanitizedName);
				for (auto& param : method->Parameters)
				{
					typeIds.push_back(param->SanitizedName);
				}
			}

			for (auto& field : classPtr->Fields)
			{
				typeIds.push_back(field->SanitizedName);
			}
		}
	}

	for (auto& enumPtr : m_fileInfo.Module.Enums)
	{
		if (enumPtr->InMainFile)
		{
			typeIds.push_back(enumPtr->SanitizedName);
		}
	}

	stream.WriteLine("// ----------------------------------------------------------------------------");
	stream.WriteLine("// Registration Functions");
	stream.WriteLine("// ----------------------------------------------------------------------------");
	stream.WriteLine("void Metadata_Register_%s()", m_fileId.c_str());
	stream.WriteLine("{");
	stream.Indent();

	for (auto iter = typeIds.begin(); iter != typeIds.end(); iter++)
	{
		stream.WriteLine("Record::RegisterRecord<%s>();", (*iter).c_str());
	}

	stream.Undent();
	stream.WriteLine("}");
	stream.WriteLine("");
	stream.WriteLine("void Metadata_Unregister_%s()", m_fileId.c_str());
	stream.WriteLine("{");
	stream.Indent();

	for (auto iter = typeIds.rbegin(); iter != typeIds.rend(); iter++)
	{
		stream.WriteLine("Record::UnregisterRecord<%s>();", (*iter).c_str());
	}

	stream.Undent();
	stream.WriteLine("}");
}

bool WriteSourceMetadataToFile::Execute()
{
	TextStream stream;

	WriteHeader(stream);

	for (auto& classPtr : m_fileInfo.Module.Classes)
	{
		if (classPtr->InMainFile && (!classPtr->IsTemplated || classPtr->IsTemplateInstance))
		{
			WriteClass(stream, classPtr);
		}
	}

	for (auto& enumPtr : m_fileInfo.Module.Enums)
	{
		if (enumPtr->InMainFile)
		{
			WriteEnum(stream, enumPtr);
		}
	}

	WriteRegistration(stream);
	WriteFooter(stream);

	if (!stream.WriteToFile(m_fileInfo.GeneratedSourcePath, true))
	{
		Log(LogSeverity::Fatal, "Failed to create generated file: %s\n", m_fileInfo.GeneratedSourcePath.ToString().c_str());
		return false;
	}

	return true;
}

}; // namespace MicroBuild